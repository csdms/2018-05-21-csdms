<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <title>Software Carpentry: Programming with Python</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="css/swc.css" />

    
<!-- 
    <link rel="stylesheet" type="text/css" href="../../assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="../../assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="../../assets/css/lesson.css" />
    
 -->
    <meta charset="UTF-8" />
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body class="lesson">
    <div class="container card">
      <div class="banner">
        <a href="http://csdms.colorado.edu" title="Community Surface Dynamics Modeling System">
          <img alt="CSDMS banner" src="img/CSDMS_banner.png" />
        </a>
      </div>
      <article>
      <div class="row">
        <div class="col-md-10 col-md-offset-1">
                    <a href="index.html"><h1 class="title">Programming with Python</h1></a>
          <h2 class="subtitle">Analyzing Topographic Data</h2>
          
          
          
<section class="objectives panel panel-warning">
<div class="panel-heading">
<h2 id="learning-objectives"><span class="glyphicon glyphicon-certificate"></span>Learning Objectives</h2>
</div>

<div class="panel-body">
<ul>
<li>Explain what a library is, and what libraries are used for</li>
<li>Load a Python library and use the tools it contains</li>
<li>Read data from a file into a program</li>
<li>Assign values to variables</li>
<li>Select individual values and subsections from data</li>
<li>Perform operations on arrays of data</li>
<li>Display simple graphs</li>
</ul>
</div>
</section>

<p>While a lot of powerful tools are built into languages like Python, even more tools exist in <a href="reference.html#library">libraries</a>.</p>
<p>In order to load the elevation data, we need to <a href="reference.html#import">import</a> a library called NumPy. You should use this library if you want to do fancy things with numbers (ie. math), especially if you have matrices or arrays. We can load NumPy using:</p>
<pre class="sourceCode"><code>import numpy</code></pre>
<p>Importing a library is like pulling a toolbox out of a storage locker and placing it on your workbench, making everything inside the toolbox accessible. Python has a set of built-in functions that are always available (the tools you always have available) and libraries provide additional functionality (the specialized tools in the toolbox you only sometimes need).</p>
<p>Once we’ve loaded the library, we can call a function inside that library to read the data file:</p>

<pre class="sourceCode"><code>numpy.loadtxt('data/topo.asc', delimiter=',')</code></pre>

<pre class="output"><code>array([[ 3198.8391,  3198.123 ,  3197.1584, ...,  2583.3293, 
    2585.4368, 2589.1079], [ 3198.3306,  3197.5242,  3196.4102, ..., 
    2582.6992,  2584.9167, 2587.801 ], [ 3197.9968,  3196.9197, 
    3195.7188, ...,  2581.8328,  2583.8159, 2586.0325], ..., [
    3325.1509,  3334.7822,  3343.3154, ...,  2780.8191,  2769.3235,
    2762.373 ], [ 3325.0823,  3335.0308,  3345.4963, ...,  2775.3345, 
    2765.7131, 2759.6555], [ 3326.6824,  3336.5305,  3348.1343, ..., 
    2769.7661,  2762.5242, 2756.6877]])</code></pre>
    
<p>The expression <code>numpy.loadtxt(...)</code> is a <a href="reference.html#function-call">function call</a> that asks Python to run the function <code>loadtxt</code> that belongs to the <code>numpy</code> library. This <a href="reference.html#dotted-notation">dotted notation</a>, with the syntax <code>thing.component</code>, is used everywhere in Python to refer to parts of things.</p>
<p>Our function call to <code>numpy.loadtxt</code> has two <a href="reference.html#parameter">parameters</a>: the name of the file we want to read, and the <a href="reference.html#delimiter">delimiter</a> that separates values on a line. Both need to be character strings (or <a href="reference.html#string">strings</a>, for short) so we write them in quotes.</p>
<p>Within the Jupyter (iPython) notebook, pressing Shift+Enter runs the commands in the selected cell. Because we haven’t told iPython where to put the output of <code>numpy.loadtxt</code>, the notebook just displays it on the screen. In this case, that output is the data we just loaded. By default, only a few rows and columns are shown (with <code>...</code> to omit elements when displaying big arrays).</p>
<p>Our call to <code>numpy.loadtxt</code> read the file but didn’t save it to memory. In order to access the data, we need to <a href="reference.html#assignment">assign</a> the values to a <a href="reference.html#variable">variable</a>. A variable is just a name that refers to an object. Python’s variables must begin with a letter and are <a href="reference.html#case-sensitive">case sensitive</a>. We can assign a variable name to an object using <code>=</code>.</p>

<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="objects-and-their-names"><span class="glyphicon glyphicon-pushpin"></span>Objects and their names</h2>
</div>

<div class="panel-body">
<p>What happens when a function is called but the output is not assigned to a variable is a bit more complicated than simply not saving it. The call to <code>numpy.loadtxt</code> read the file and created an object in memory that contains the data, but because we didn’t assign it to a variable name, there is no way for us to call this object. While this difference might seem irrelevant (and, in practice, it probably is), it will be important to consider how variable names are assigned to objects when we talk about mutable and immutable objects later on.</p>
<p>A good explanation of how Python handles variables and objects can be found <a href="https://jeffknupp.com/blog/2012/11/13/is-python-callbyvalue-or-callbyreference-neither/">in Jeff Knupp’s blog</a>.</p>
</div>
</aside>

<p>Let’s re-run <code>numpy.loadtxt</code> and assign the output to a variable name:</p>
<pre class="sourceCode"><code>topo = numpy.loadtxt(<span class="st">'data/topo.asc'</span>, delimiter=<span class="st">','</span>)</code></pre>
<p>This command doesn’t produce any visible output. If we want to see the data, we can print the variable’s value with the command <code>print</code>:</p>
<pre class="sourceCode"><code>print topo</code></pre>
<pre class="output"><code>    [[ 3198.8391  3198.123   3197.1584 ...,  2583.3293  2585.4368 
    2589.1079] [ 3198.3306  3197.5242  3196.4102 ...,  2582.6992 
    2584.9167  2587.801 ] [ 3197.9968  3196.9197  3195.7188 ..., 
    2581.8328  2583.8159  2586.0325] ..., [ 3325.1509  3334.7822 
    3343.3154 ...,  2780.8191  2769.3235  2762.373 ] [ 3325.0823 
    3335.0308  3345.4963 ...,  2775.3345  2765.7131  2759.6555] [
    3326.6824  3336.5305  3348.1343 ...,  2769.7661  2762.5242 
    2756.6877]]</code></pre>
    
    
    

<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="check-your-understanding"><span class="glyphicon glyphicon-pencil"></span>Check your understanding</h2>
</div>

<div class="panel-body">
<p>Track how variable names and objects are connected after each statement in the following program:</p>
<pre class="sourceCode"><code>mass = <span class="fl">47.5</span>
age = <span class="dv">122</span>
mass = mass <span class="op">*</span> <span class="fl">2.0</span>
age = age <span class="op">-</span> <span class="dv">20</span></code></pre>
</div>
</section>


<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="sorting-out-references"><span class="glyphicon glyphicon-pencil"></span>Sorting out references</h2>
</div>

<div class="panel-body">
<p>What does the following program print?</p>
<pre class="sourceCode"><code>first, second = <span class="st">'Grace'</span>, <span class="st">'Hopper'</span>
third, fourth = second, first
print third, fourth</code></pre> 
<p>Bonus: Who was Grace Hopper?</p>
</div>

<div class="panel-heading solution">
    <h2>Solution </h2>
    <pre class="output"><code> Hopper Grace
</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Grace_Hopper">https://en.wikipedia.org/wiki/Grace_Hopper</a></p>
  </div>

</section>


<p>Using its variable name, we can see that <a href="reference.html#type">type</a> of object the variable name <code>topo</code> is assigned to:</p>
<pre class="sourceCode"><code>print <span class="bu">type</span>(topo)</code></pre>
<pre class="output"><code>    &lt;type 'numpy.ndarray'&gt;</code></pre>
<p>The function <code>type</code> tells us that the variable name <code>topo</code> currently points to an N-dimensional array created by the NumPy library. We can also get the shape of the array:</p>
<pre class="sourceCode"><code>print topo.shape</code></pre>
<pre class="output"><code>(500, 500)</code></pre>
<p>This tells us that <code>topo</code> has 500 rows and 500 columns. The file we imported contains elevation data (in meters, 2 meter x 2 meter cells) for an area along the Front Range of Colorado, just south of Boulder. The area that this array represents is 1 km x 1 km.</p>
<p>The object of type <code>numpy.ndarray</code> that the variable <code>topo</code> is assigned to contains the values of the array as well as some extra information about the array. These are the <a href="reference.html#member">members</a> or attributes of the object, and they describe the data in the same way an adjective describes a noun. The command <code>topo.shape</code> calls the <code>shape</code> attribute of the object with the variable name <code>topo</code> that describes its dimensions. We use the same dotted notation for the attributes of objects that we use for the functions inside libraries because they have the same part-and-whole relationship.</p>

<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="len-and-other-built-in-functions"><span class="glyphicon glyphicon-pushpin"></span>len() and other built-in functions</h2>
</div>

<div class="panel-body">
<p>The function <code>len()</code> returns the length of the longest axis of a sequence (a numpy array, a list, etc.). Because it is a built-in function, it is always available for the Python interpreter and doesn’t have to be imported. The function <code>type()</code> is another built in function. You can read about them in the <a href="https://docs.python.org/2/library/functions.html">Python docs</a>.</p>
</div>
</aside>


<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="whos-who-in-the-memory"><span class="glyphicon glyphicon-pushpin"></span>Who’s who in the memory</h2>
</div>

<div class="panel-body">
<p>You can use the whos command at any time to see what variables you have created and what modules you have loaded into the computers memory. As this is an IPython command, it will only work if you are in an iPython terminal or the Jupyter Notebook.</p>
<pre class="sourceCode"><code>whos</code></pre>
<pre class="output"><code>Variable    Type       Data/Info
--------------------------------
numpy       module     &lt;module 'numpy' from '/Us&lt;...&gt;kages/numpy/__init__.py'&gt;
topo        ndarray    500x500:250000 elems, type `float64`, 2000000 bytes (1 Mb)</code></pre>
</div>
</aside>

<h2 id="plotting">Plotting</h2>
<p>Rasters are just big two dimensional arrays of values. In the case of DEMs, those values are elevations. It’s very hard to get a good sense of what this landscape looks like by looking directly at the data. This information is better conveyed through plots and graphics.</p>
<p>Data visualization deserves an entire lecture (or course) of its own, but we can explore a few features of Python’s <code>matplotlib</code> library here. While there is no “official” plotting library in Python, this package is the de facto standard.</p>
<p>We start by importing the <code>pyplot</code> module from the library <code>matplotlib</code>:</p>
<pre class="sourceCode"><code>import matplotlib.pyplot</code></pre>

<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="some-ipython-magic"><span class="glyphicon glyphicon-pushpin"></span>Some IPython magic</h2>
</div>

<div class="panel-body">
<p>If you’re using an IPython / Jupyter notebook, you’ll need to execute the following command in order for the plots to appear in the notebook instead of a separate window:</p>
<pre class="sourceCode"><code><span class="op">%</span>matplotlib inline</code></pre>
<p>The <code>%</code> indicates an IPython magic function - a function that is only valid within the notebook environment. Note that you only have to execute this function once per notebook.</p>
</div>
</aside>

<p>We can use the function <code>imshow</code> within <code>matplotlib.pyplot</code> to display arrays as a 2D image:</p>
<pre class="sourceCode"><code>matplotlib.pyplot.imshow(topo)</code></pre>

<div class="figure">
<img src="fig/output_24_1.png" alt="" />

</div>
<h2 id="indexing">Indexing</h2>
<p>We can access individual values in an array using an <a href="reference.html#index">index</a> in square brackets:</p>
<pre class="sourceCode"><code>print <span class="st">'elevation at the NE corner of topo:'</span>, topo[<span class="dv">0</span>,<span class="dv">0</span>], <span class="st">'meters'</span></code></pre>
<pre class="output"><code>elevation at the NE corner of topo: 3198.8391 meters</code></pre>
<pre class="sourceCode"><code>print <span class="st">'elevation at an arbitrary point in topo:'</span>, topo[<span class="dv">137</span>,<span class="dv">65</span>],
<span class="co">'meters'</span></code></pre>
<pre class="output"><code>elevation at an arbitrary spot in topo: 3251.1179 meters</code></pre>
<p>When referring to entries in a two dimensional array, the indices are ordered <code>[row,column]</code>. The expression <code>topo[137, 65]</code> should not surprise you but <code>topo[0,0]</code> might. Programming languages like Fortran and MATLAB start counting at 1 because that’s what (most) humans have done for thousands of years. Languages in the C family (including C++, Java, Perl, and Python) count from 0 because that’s simpler for computers to do. So if we have an M×N array in Python, the indices go from 0 to M-1 on the first axis (rows) and 0 to N-1 on the second (columns). In MATLAB, the same array (or matrix) would have indices that go from 1 to M and 1 to N. Zero-based indexing takes a bit of getting used to, but one way to remember the rule is that the index is how many steps we have to take from the start to get to the item we want.</p>
<p>Python also allows for negative indices to refer to the position of elements with respect to the end of each axis. An index of -1 refer to the last item in a list, -2 is the second to last, and so on. Since index <code>[0,0]</code> is the upper left corner of an array, index <code>[-1,-1]</code> therefore the lower right corner of the array:</p>
<pre class="sourceCode"><code>print topo[<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>]</code></pre>
<pre class="output"><code>2756.6877</code></pre>

<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="in-the-corner"><span class="glyphicon glyphicon-pushpin"></span>In the Corner</h2>
</div>

<div class="panel-body">
<p>What may also surprise you is that when Python displays an array, it shows the element with index <code>[0, 0]</code> in the upper left corner rather than the lower left. This is consistent with the way mathematicians draw matrices, but different from the Cartesian coordinates. The indices are (row, column) instead of (column, row) for the same reason, which can be confusing when plotting data.</p>
</div>
</aside>

<h2 id="slicing">Slicing</h2>
<p>A command like <code>topo[0,0]</code> selects a single element in the array <code>topo</code>. Indices can also be used to <a href="reference.html#slice">slice</a> sections of the array. For example, we can select the top left quarter of the array like this:</p>
<pre class="sourceCode"><code>print topo[<span class="dv">0</span>:<span class="dv">5</span>, <span class="dv">0</span>:<span class="dv">5</span>]</code></pre>
<pre class="output"><code>[[ 3198.8391  3198.123   3197.1584  3196.2017  3193.8813] [
    3198.3306  3197.5242  3196.4102  3194.7559  3191.9763] [ 3197.9968 
    3196.9197  3195.7188  3193.3855  3190.5371] [ 3198.054   3196.7031 
    3194.9573  3192.4451  3189.5288] [ 3198.3289  3196.9111  3195.335  
    3192.7874  3190.0085]]
</code></pre>
<p>The slice <code>[0:5]</code> means “Start at index 0 and go along the axis up to, but not including, index 5”.</p>
<p>We don’t need to include the upper or lower bound of the slice if we want to go all the way to the edge. If we don’t include the lower bound, Python uses 0 by default; if we don’t include the upper bound, the slice runs to the end of the axis. If we don’t include either (i.e., if we just use ‘:’), the slice includes everything:</p>
<pre class="sourceCode"><code>print topo[:<span class="bu">len</span>(topo)<span class="op">/</span><span class="dv">2</span>, <span class="bu">len</span>(topo)<span class="op">/</span><span class="dv">2</span>:]</code></pre>
<pre class="output"><code>[[ 3008.1116  3012.2922  3015.3018 ...,  2583.3293  2585.4368 
    2589.1079] [ 3009.9558  3014.0007  3016.5647 ...,  2582.6992 
    2584.9167  2587.801 ] [ 3010.8604  3014.1228  3016.7412 ..., 
    2581.8328  2583.8159  2586.0325] ..., [ 3370.0918  3368.5371 
    3366.7148 ...,  2687.8396  2682.4326  2676.8521] [ 3370.478  
    3368.7561  3366.8923 ...,  2685.9941  2681.2888  2676.9924] [
    3371.2021  3369.3376  3367.3677 ...,  2687.7014  2685.5146 
    2683.1936]]</code></pre>

<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="point-elevations"><span class="glyphicon glyphicon-pencil"></span>Point elevations</h2>
</div>

<div class="panel-body">
<p>Use indexing to answer the following questions and check your answers against the data visualization:</p>
<ul>
<li>Is the NW corner of the region higher than the SW corner? What’s the elevation difference?</li>
<li>What’s the elevation difference between the NE corner and the SE corner?</li>
<li>What’s the elevation at the center of the region shown in the array?</li>
</ul>
</div>
</section>
<br>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="slicing-strings"><span class="glyphicon glyphicon-pencil"></span>Slicing strings</h2>
</div>


<div class="panel-body">
  <p>A section of an array is called a <a href="../reference/#slice">slice</a>.
Indexing and slicing behave the same way for any type of sequence, including numpy arrays, lists, and strings:</p>

  <pre class="sourceCode"><code>element = 'oxygen'
print('first three characters:', element[0:3])
print('last three characters:', element[3:6])
</code></pre>

  <pre class="output"><code>first three characters: oxy
last three characters: gen
</code></pre>
<br>
<li>What is the value of <code>element[:4]</code>?
What about <code>element[4:]</code>?
Or <code>element[:]</code>?</li>
</div>
  <div class="panel-heading solution">
    <h2>Solution </h2>
    <pre class="output"><code>oxyg
en
oxygen
</code></pre>
  </div>
<div class="panel-body">
<li>What is <code class="highlighter-rouge">element[-1]</code>?
What is <code class="highlighter-rouge">element[-2]</code>?</li></div>
  
  <div class="panel-heading solution">
    <h2>Solution </h2>
    <pre class="output"><code>n, e
</code></pre>
  </div>

<div class="panel-body">
<li>Given those answers,
explain what <code class="highlighter-rouge">element[1:-1]</code> does.</li></div>

<div class="panel-heading solution">
    <h2>Solution </h2>
    <br><p>Creates a substring from index 1 up to (not including) the final index,
effectively removing the first and last letters from ‘oxygen’
</p>
  </div>
</section>

<br>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="thin-slices"><span class="glyphicon glyphicon-pencil"></span>Thin slices</h2>
</div>

<div class="panel-body">

  <p>The expression <code class="highlighter-rouge">element[3:3]</code> produces an <a href="../reference/#empty-string">empty string</a>,
i.e., a string that contains no characters.
If <code class="highlighter-rouge">data</code> holds our array of patient data,
what does <code class="highlighter-rouge">data[3:3, 4:4]</code> produce?
What about <code class="highlighter-rouge">data[3:3, :]</code>?</p>
</div>

<div class="panel-heading solution">
    <h2>Solution </h2>
    <div class="output highlighter-rouge"><pre class="highlight"><code>[]
[]
</code></pre>
    </div>
</section>
<br>

<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="stitching-strings"><span class="glyphicon glyphicon-pencil"></span>Stitching strings</h2>
</div>

<div class="panel-body">
<p>Create a new variable called <code>text</code> and assign it the string “The quick brown fox jumped over the lazy dog.”
(note the capitalization and punctuation and include the quotes so Python recognizes it as a string).
Then use slicing and the <code>print</code> statement to extract and combine pieces of the string in <code>text</code> and create these frases (Again, note capitalization and punctuation!):</p>
<p>NOTE: You can use the plus sign (+) to add strings together! Try it by running <code>print "lazy" + "dog"</code>.
<ul>
<li>the lazy dog.</li>
<li>The fox jumped over the dog</li>
<li>The lazy fox jumped over the quick brown dog.</li>
</ul>
</div>
</section>


<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="plotting-smaller-regions"><span class="glyphicon glyphicon-pencil"></span>Plotting smaller regions</h2>
</div>

<div class="panel-body">
<p>Use the function <code>imshow</code> from <code>matplotlib.pyplot</code> to make one plot showing the northern half of the region and another plot showing the southern half.</p>
<p>Then try making four separate plots showing each quarter of the region separately.</p>
</div>
</section>


<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="non-square-arrays"><span class="glyphicon glyphicon-pencil"></span>Non-square arrays</h2>
</div>

<div class="panel-body">
<p>We’ve been using <code>len(topo)/2</code> as both the row and column indices of the center point in the array <code>topo</code>. This doesn’t work with an array that’s not square (has different height and width).</p>
<ul>
<li><p>Take a (small) slice of the array <code>topo</code> and assign it to a new variable. Make this new array have a height longer than its width, and make both the height and width even numbers (4 x 6 is a good size).</p></li>
<li><p>Access the center point of your new array. Write the indices using variables, not numbers (ie. don’t write <code>t[2,3]</code>) (Hint: <code>topo.shape</code> gives the number of rows and columns in <code>topo</code>. The function <code>len(topo)</code> returns the length of the longest axis. Instead of using <code>len()</code>, assign the output of <code>shape</code> to a variable and use indexing). Are you <em>really</em> pointing to the center of your array? How far off are you?</p></li>
</ul>
</div>
</section>

<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="integers-and-floats"><span class="glyphicon glyphicon-pushpin"></span>Integers and floats</h2>
</div>

<div class="panel-body">
<p>Both the array <code>topo</code> and the one you created in the last challenge have even numbers of rows and columns.
In that case, the vakue of <code>width/2</code> and <code>height/2</code> were whole numbers (and therefore valid indices).
<em>Mysteriously</em>, <code>len(topo)/2</code> would work as an index even if the array <code>topo</code> had an odd number of rows and columns.</p>

<p>In the real world, dividing an odd number by 2 results in a number with a decimal point (ie. half of 7 is 3.5). In Python 2 (but not Python 3!), that’s not always the case:</p>
<pre class="sourceCode"><code>print <span class="st">'7/2 ='</span>, <span class="dv">7</span><span class="op">/</span><span class="dv">2</span></code></pre>
<pre class="output"><code>7/2 = 3</code></pre>
<p>In Python 2.x, dividing one whole number (the number 7) by another whole number (the number 2) always results in a whole number. If either number is a decimal, division behaves as expected and returns a decimal:</p>
<pre class="sourceCode"><code>print <span class="st">'7.0000000001/2 ='</span>, <span class="fl">7.0000000001</span><span class="op">/</span><span class="dv">2</span></code></pre>
<pre class="output"><code>7.0000000001/2 = 3.50000000005</code></pre>
<p>For computers, integers (whole numbers) and floats (or floating point numbers, decimals) are object of different <a href="reference.html#type">type</a> and sometimes behave differently:</p>
<pre class="sourceCode"><code>print <span class="st">'7 is an integer:'</span>, <span class="bu">type</span>(<span class="dv">7</span>)
print <span class="st">'7.0000000001 is a float:'</span>, <span class="bu">type</span>(<span class="fl">7.0000000001</span>)</code></pre>
<pre class="output"><code>7 is an integer: &lt;type 'int'&gt;
7.0000000001 is a float: &lt;type 'float'&gt;</code></pre>
<p>While this might seem strange and unnecessarily annoying, some programming languages use integer division for historical reasons: integers take up less space in memory and integer operations were much faster on early machines. This behavior can easily introduce bugs into your code but it is actually useful in a lot of situations (Python 3.x does not use integer division by default but returns a float when appropriate).</p>
<p>Whole numbers are treated as floats if they have decimal point:</p>
<pre class="sourceCode"><code>print <span class="st">'7 is'</span>, <span class="bu">type</span>(<span class="dv">7</span>)
print <span class="st">'-'</span> <span class="op">*</span> <span class="dv">20</span>
print <span class="st">'7. is'</span>, <span class="bu">type</span>(<span class="dv">7</span>.)
print <span class="st">'7.0 is'</span>, <span class="bu">type</span>(<span class="fl">7.0</span>)</code></pre>
<pre class="output"><code>7 is &lt;type 'int'&gt;
--------------------
7. is &lt;type 'float'&gt;
7.0 is &lt;type 'float'&gt;</code></pre>
<p>The integer assigned to a variable can be used as a float through <strong>casting</strong>:</p>
<pre class="sourceCode"><code>type_int = <span class="dv">7</span>
type_float = <span class="bu">float</span>(type_int)

print <span class="st">'type_int is'</span>, <span class="bu">type</span>(type_int)
print <span class="st">'float(type_int) is'</span>,
<span class="bu">type</span>(type_float)</code></pre>
<pre class="output"><code>type_int is &lt;type 'int'&gt;
float(type_int) is &lt;type 'float'&gt;</code></pre>
<p>Casting doesn’t permanently change the value of the original object, though:</p>
<pre class="sourceCode"><code>print <span class="st">'type_int/2 ='</span>, type_int<span class="op">/</span><span class="dv">2</span>
print <span class="st">'float(type_int)/2 ='</span>, <span class="bu">float</span>(type_int)<span class="op">/</span><span class="dv">2</span></code></pre>
<pre class="output"><code>type_int/2 = 3
float(type_int)/2 = 3.5</code></pre>
</div>
</aside>

<h2 id="numerical-operations-on-arrays">Numerical operations on arrays</h2>
<p>We can perform basic mathematical operations on each individual element of a NumPy array. We can create a new array with elevations in feet:</p>
<pre class="sourceCode"><code>topo_in_feet = topo <span class="op">*</span> <span class="fl">3.2808</span>
print <span class="st">'Elevation in meters:'</span>, topo[<span class="dv">0</span>,<span class="dv">0</span>]
print <span class="st">'Elevation in feet:'</span>, topo_in_feet[<span class="dv">0</span>,<span class="dv">0</span>]</code></pre>
<pre class="output"><code>Elevation in meters: 3198.8391
Elevation in feet: 10494.7513193</code></pre>
<p>Arrays of the same size can be used together in arithmatic operations:</p>
<pre class="sourceCode"><code>double_topo = topo <span class="op">+</span> topo
print <span class="st">'Double topo:'</span>, double_topo[<span class="dv">0</span>,<span class="dv">0</span>], <span class="st">'meters'</span></code></pre>
<pre class="output"><code>Double topo: 6397.6782 meters</code></pre>
<p>We can also perform statistical operations on arrays:</p>
<pre class="sourceCode"><code>print <span class="st">'Mean elevation:'</span>, numpy.mean(topo), <span class="st">'meters'</span></code></pre>
<pre class="output"><code>Mean elevation: 3153.62166407 meters</code></pre>
<br>

<p>The command <code>numpy.mean()</code> calls the mean function of the library Numpy. We can perform the same operation with a method -- a function that belongs to the Numpy array <code>topo</code>. A subset of Numpy functions have equivalent methods:</p>
<pre class="sourceCode"><code>print <span class="st">'Mean elevation:'</span>, topo.mean(), <span class="st">'meters'</span></code></pre>
<pre class="output"><code>Mean elevation: 3153.62166407 meters</code></pre>

<br>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="not-all-functions"><span class="glyphicon glyphicon-pushpin"></span>Not All Functions Have Input</h2>
</div>
<div class="panel-body">
  <p>Generally, a function uses inputs to produce outputs.
However, some functions produce outputs without
needing any input. For example, checking the current time
doesn’t require any input.</p>

<pre class="sourceCode"><code>import time
print time.ctime()
</code></pre>

<pre class="output"><code>'Sat Mar 26 13:07:33 2016'
</code></pre>

  <p>For functions that don’t take in any arguments,
we still need parentheses (<code>()</code>)
to tell Python to go and do something for us.</p>
</div>
</aside>

<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="methods-vs.attributes"><span class="glyphicon glyphicon-pushpin"></span>Methods vs. attributes</h2>
</div>

<div class="panel-body">
<p><code>mean</code> is a method that belongs to the array <code>topo</code>, i.e., it is a function <code>topo</code> can inherently call just because of its type. When we call <code>topo.mean()</code>, we are asking <code>topo</code> to calculate its mean value. Because it is a function, we need to include parenthesis in the command. Because it is an <code>np.array</code>, <code>topo</code> also has an attribute called <code>shape</code>, but it doesn’t include parenthesis because attributes are objects, not functions.</p>
<p>Python will kindly tell us if we mix up the parentheses:</p>
<pre class="sourceCode"><code>topo.mean</code></pre>
<pre class="output"><code>&lt;function mean&gt;</code></pre>
<pre class="sourceCode"><code>topo.shape()</code></pre>
<pre class="output"><code>--------------------------------------------------------------------
-------

TypeError                                 Traceback (most recent
call last)

&lt;ipython-input-29-5f3a6f1ecafc&gt; in &lt;module&gt;() ----&gt; 1 topo.shape()

TypeError: 'tuple' object is not callable</code></pre>
</div>
</aside>

<p>NumPy arrays have many other useful methods:</p>
<pre class="sourceCode"><code>print <span class="st">'Highest elevation:'</span>, topo.<span class="bu">max</span>(), <span class="st">'meters'</span>
print <span class="st">'Lowest elevation:'</span>, topo.<span class="bu">min</span>(), <span class="st">'meters'</span> </code></pre>
<pre class="output"><code>Highest elevation: 3831.2617 meters
Lowest elevation: 2565.0293 meters</code></pre>
<p>We can also call methods on slices of the array:</p>
<pre class="sourceCode"><code>half_len = <span class="bu">int</span>(<span class="bu">len</span>(topo) <span class="op">/</span> <span class="dv">2</span>)

print <span class="st">'Highest elevation of NW quarter:'</span>, topo[:half_len,
:half_len].<span class="bu">max</span>(), <span class="st">'meters'</span>

print <span class="st">'Highest elevation of SE quarter:'</span>, topo[half_len:,
half_len:].<span class="bu">max</span>(), <span class="st">'meters'</span> </code></pre>
<pre class="output"><code>Highest elevation of NW quarter: 3600.709 meters
Highest elevation of SE quarter: 3575.3262 meters</code></pre>
<p>Methods can also be used along individual axes (rows or columns) of an array. If we want to see how the mean elevation changes with longitude (E-W), we can use the method along <code>axis=0</code>:</p>
<pre class="sourceCode"><code>print topo.mean(axis=<span class="dv">0</span>) </code></pre>
<p>To see how the mean elevation changes with latitude (N-S), we can use <code>axis=1</code>:</p>
<pre class="sourceCode"><code>print topo.mean(axis=<span class="dv">1</span>) </code></pre>


<h2 id="plotting-take-two">Plotting, take two</h2>

<p>It’s hard to get a sense of how the topography changes across the landscape from big tables of numbers. A simpler way to display this information is with line plots.</p>
<p>We are again going to use the <code>matplotlib</code> package for data visualization. Since we imported the <code>matplotlib.pyplot</code> library once already in this Jupyter (IPython) Notebook, those tools are available and can be called. As a review, though, we are going to write every step that's needed to load and plot the data.</p>
<p>We use the function <code>plot</code> to create two basic line plots across the topography:</p>
<pre class="sourceCode"><code>import numpy <span class="im">as</span> np
import matplotlib.pyplot <span class="im">as</span> plt
<span class="op">%</span>matplotlib inline

topo = np.loadtxt(<span class="st">'data/topo.asc'</span>, delimiter=<span class="st">','</span>)

plt.plot(topo[<span class="dv">0</span>,:])
plt.show()

plt.plot(topo[<span class="op">-</span><span class="dv">1</span>,:], <span class="st">'r--'</span>)
plt.show() </code></pre>

<div class="figure">
<img src="fig/output_14_0.png" alt="" /></div>

<div class="figure">
<img src="fig/output_14_1.png" alt="" /></div>
<br><br>

<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="scientists-dislike-typing"><span class="glyphicon glyphicon-pushpin"></span>Scientists dislike typing</h2>
</div>

<div class="panel-body">
<p>We will always use the syntax <code>import numpy</code> to import Numpy. However, in order to save typing, it is <a href="http://www.scipy.org/getting-started.html#an-example-script">often suggested</a> to make a shortcut like so: <code>import numpy as np</code>. If you ever see Python code using a Numpy function with <code>np</code> (for example, <code>np.loadtxt(...)</code>), it’s because they’ve used this shortcut.</p>
</div>
</aside>

<p>To more easily compare these profiles, we can plot them as separate lines in a single figure using the argument <code>hold=True</code>. This will force all subsequent calls to <code>plt.plot</code> to use the same axes (until it reaches <code>plt.show()</code>). The argument <code>label=</code> holds the label that will appear in the legend.</p>
<pre class="sourceCode"><code>import numpy <span class="im">as</span> np import matplotlib.pyplot <span class="im">as</span> plt
<span class="op">%</span>matplotlib inline

topo = np.loadtxt(<span class="st">'data/topo.asc'</span>, delimiter=<span class="st">','</span>)

plt.plot(topo[<span class="dv">0</span>,:], hold=<span class="va">True</span>, label=<span class="st">'North'</span>)

plt.plot(topo[<span class="op">-</span><span class="dv">1</span>,:], <span class="st">'r--'</span>, label=<span class="st">'South'</span>)

plt.plot(topo[<span class="bu">len</span>(topo)<span class="op">/</span><span class="dv">2</span>,:], <span class="st">'g:'</span>, linewidth=<span class="dv">3</span>, label=<span class="st">'Mid'</span>)

plt.title(<span class="st">'Topographic profiles'</span>)
plt.ylabel(<span class="st">'Elevation (m)'</span>)
plt.xlabel(<span class="st">'&lt;-- West    East --&gt;'</span>)
plt.legend(loc = <span class="st">'lower left'</span>)

plt.show() </code></pre>

<div class="figure">
<img src="fig/output_2_0.png" alt="" />

</div>

<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="make-your-own-plots"><span class="glyphicon glyphicon-pencil"></span>Make your own plots</h2>
</div>

<div class="panel-body">
<p>Create three separate plots showing how the maximum (<code>numpy.max()</code>), minimum (<code>numpy.min()</code>), and mean (<code>numpy.mean()</code>) elevation changes with longitude. Label the axes and include a title for each of the plots (Hint: use <code>axis=0</code>).</p>
<p>Convert the separate plots into a single plot that includes all three statistics (using <code>hold=True</code>). Create a legend.</p>
</div>
</section>


<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="subplots"><span class="glyphicon glyphicon-pencil"></span>Subplots</h2>
</div>

<div class="panel-body">
<p>We often want to arrange separate plots in layouts with multiple rows and columns. The script below uses subplots to show the elevation profile at the western edge, the mid longitude, and eastern edge of the region. Subplots can be a little weird because they require the axes to be defined before plotting. Type (don’t copy-paste!) the code below to get a sense of how it works.</p>
<p>This script uses a number of new commands:</p>
<ul>
<li>The function <code>plt.figure()</code> creates a space into which we will place the three plots.</li>
<li>The parameter <code>figsize</code> tells Python how big to make this space.</li>
<li>Each subplot is placed into the figure using the <code>subplot</code> command.</li>
<li>The <code>subplot</code> command takes 3 parameters: the first denotes the total number of rows of subplots in the figure, the second is the total number of columns of subplots in the figure, and the final parameters identifies the position of the subplot in the grid.</li>
<li>The axes of the subplots are assigned to variable names (here, <code>axes1, axes2, axes3, axes4</code>).</li>
<li>Once a subplot is created, its axes can be labeled using the <code>set_xlabel()</code> (or <code>set_ylabel()</code>) method.</li>
<li><code>plt.show()</code> is called after the entire figure is set up. The Jupyter Notebooks don't need this command to show the figure but you should get in the habit of using it!</li>
<br>

<pre class="sourceCode"><code>import numpy <span class="im">as</span> np
import matplotlib.pyplot <span class="im">as</span> plt
<span class="op">%</span>matplotlib inline

topo = np.loadtxt(<span class="st">'data/topo.asc'</span>, delimiter=<span class="st">','</span>)

fig = plt.figure(figsize=(<span class="fl">16.0</span>, <span class="fl">3.0</span>))

axes1 = fig.add_subplot(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">1</span>)
axes2 = fig.add_subplot(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>)
axes3 = fig.add_subplot(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">3</span>)

axes1.plot(topo[:,<span class="dv">0</span>])
axes1.set_ylabel(<span class="st">'Elevation (m)'</span>)
axes1.set_xlabel(<span class="st">'&lt;-- N   S --&gt;'</span>)
axes1.set_title(<span class="st">'West'</span>)

axes2.plot(topo[:,<span class="bu">len</span>(topo)<span class="op">/</span><span class="dv">2</span>])
axes2.set_xlabel(<span class="st">'&lt;-- N   S --&gt;'</span>)
axes2.set_title(<span class="st">'Mid'</span>)

axes3.plot(topo[:,<span class="op">-</span><span class="dv">1</span>])
axes3.set_xlabel(<span class="st">'&lt;--N   S --&gt;'</span>)
axes3.set_title(<span class="st">'East'</span>)

plt.show(fig) </code></pre>
</div>
</section>

<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="subplots"><span class="glyphicon glyphicon-pencil"></span>Plot Scaling</h2>
</div>

<div class="panel-body">
  <li>Why do the lines in all of our plots stop just short of the upper end of our graph?</li>
</div>
<div class="panel-heading solution">
    <h2>Solution </h2>
    <br><p>Because matplotlib normally sets x and y axes limits to the min and max of our data (depending on data range).</p>
  </div>
  
<div class="panel-body">
  <p>If we want to change this, we can use the <code class="highlighter-rouge">set_ylim(min, max)</code> method of each ‘axes’,
for example:</p>

  <pre class="sourceCode"><code>axes3.set_ylim(0,6)
</code></pre>

  <li>Update your plotting code to automatically set a more appropriate scale
(Hint: you can make use of the <code>max</code> and <code>min</code> methods to help).</li>
</div>  
  <div class="panel-heading solution">
    <h2>Solution </h2>
    <pre class="sourceCode"><code># Solution 1:
axes3.set_ylabel('min')
axes3.plot(numpy.min(data, axis=0))
axes3.set_ylim(0,6)
</code></pre>
    <pre class="sourceCode"><code># Solution 2: A more automated approach
min_data = numpy.min(data, axis=0)
axes3.set_ylabel('min')
axes3.plot(min_data)
axes3.set_ylim(numpy.min(min_data), numpy.max(min_data) * 1.1)
</code></pre>
  </div> 
</section>  
<br>

<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="subplots"><span class="glyphicon glyphicon-pencil"></span>Moving Plots Around</h2>
</div>
<div class="panel-body">
 <li>Modify the subplot script to display the three plots on top of one another
instead of side by side. Set limits to the y axes of all plots.</li>
</div>
<div class="panel-heading solution">
    <h2>Solution </h2>
<pre class="sourceCode"><code>import numpy <span class="im">as</span> np
import matplotlib.pyplot <span class="im">as</span> plt
<span class="op">%</span>matplotlib inline

topo = np.loadtxt(<span class="st">'data/topo.asc'</span>, delimiter=<span class="st">','</span>)

fig = plt.figure(figsize=(<span class="fl">16.0</span>, <span class="fl">3.0</span>))

axes1 = fig.add_subplot(<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">1</span>)
axes2 = fig.add_subplot(<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>)
axes3 = fig.add_subplot(<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">3</span>)

axes1.plot(topo[:,<span class="dv">0</span>])
axes1.set_ylim([<span class="dv">2500</span>,<span class="dv">3900</span>])
axes1.set_xlabel(<span class="st">'&lt;-- N   S --&gt;'</span>)
axes1.set_title(<span class="st">'West'</span>)

axes2.plot(topo[:,<span class="bu">len</span>(topo)<span class="op">/</span><span class="dv">2</span>])
axes2.set_ylim([<span class="dv">2500</span>,<span class="dv">3900</span>])
axes2.set_ylabel(<span class="st">'Elevation (m)'</span>)
axes2.set_xlabel(<span class="st">'&lt;-- N   S --&gt;'</span>)
axes2.set_title(<span class="st">'Mid'</span>)

axes3.plot(topo[:,<span class="op">-</span><span class="dv">1</span>])
axes3.set_ylim([<span class="dv">2500</span>,<span class="dv">3900</span>])
axes3.set_xlabel(<span class="st">'&lt;--N   S --&gt;'</span>)
axes3.set_title(<span class="st">'East'</span>)

plt.show(fig) </code></pre>
</div>
</section>

<br>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="subplots-of-dems"><span class="glyphicon glyphicon-pencil"></span>Subplots of DEMs</h2>
</div>

<div class="panel-body">
<p>Make a 2x2 grid of subplots that use the function <code>imshow</code> to display each quarter of the dataset (ie. split down the middle in both x and y).</p>
<ul>
<li>Don’t label axes or add a colorbar. It can be tricky to do this with subplots.</li>
<li>To set the range of colors for one subplot, include the arguments <code>vmin</code> and <code>vmax</code> in <code>imshow</code> like this:</li>
</ul>
<pre class="sourceCode"><code>min_val = topo.<span class="bu">min</span>()
max_val = topo.<span class="bu">max</span>()

plt.imshow(topo, vmin=min_val, vmax=max_val) </code></pre>
</div>
</section>

        </div>
      </div>
      </article>
      <div class="footer">
        <a class="label swc-blue-bg" href="http://csdms.colorado.edu">CSDMS</a>
        <a class="label swc-blue-bg" href="https://github.com/csdms/2017-05-22-csdms/">Source</a>
        <a class="label swc-blue-bg" href="mailto:perignon@colorado.edu">Contact</a>
        <a class="label swc-blue-bg" href="LICENSE.html">License</a>
      </div>
    </div>
    <!-- Javascript placed at the end of the document so the pages load faster -->
<!-- 
    <script src="http://software-carpentry.org/v5/js/jquery-1.9.1.min.js"></script>
    <script src="css/bootstrap/bootstrap-js/bootstrap.js"></script>
 -->
    <script src="js/jquery.min.js"></script>
<script src="js/bootstrap.min.js"></script>
    <script src="js/lesson.js"></script>
  </body>
</html>
